好同学们
接下来我们就开始第一章的学习
初始docker啊

这一章里啊
我们会了解一下`什么是docker以及docker的工作原理`
`还有docker和虚拟机之间的差别`
然后呢我们还会`学习一下docker的工作架构`
和`它里边的一些概念`
最后我们还会去带着大家安装docker啊
下边呢我们就开始第一部分
了解一下什么是docker以及它的工作原理
不过要了解这一部分
我们还需要先看一下`项目部署所碰到的问题啊`    

`一个大型的项目组件往往很多
特别是微服务项目
各种各样的微服务
而且这些微服务啊还会依赖于各种各样的应用`
比如说前端部分肯定依赖运动的js吧
而我们的服务端呢还需要数据库mysql缓存系统
redis
还有我们后面会学习的一部通信
mq等等这些技术
而且还会有更多更多
这只是其中的一部分
那`所有的这些应用啊
将来都需要部署我们的服务器上`
而大多数的服务器都会采用linux的系统
那应用啊在安装的linux操作系统之前
要做一些准备工作
因为`这些应用都会有自己所需要的
一些依赖和函数库`
那每一个不同的应用
`它们所需要的依赖和函数库可能有差异`
也有可能一样
但是版本不同
那这个时候`如此复杂的一个依赖关系
很容易啊
就产生兼容性的问题
而且你费了老半天劲
终于把这些问题全部解决了`
你会发现这只是一个开始
你搞定了`开发环境
还有测试环境
生产环境
预发布环境`等等在等着你
最可怕的是这些环境
他们的linux操作系统还有可能不同
你比如说我这里装了一个windows系统
然后呢还有一个环境里装的是fedora系统
还有一个装的是乌班图系统
那怎么办呀
你在这个环境下配好了
各种东西你换到另外一个操作系统里
它还能正常运行吗
那肯定是不行的
那这就是我们现在啊开发时
或者说部署时所碰到的各种各样的问题
因此呢在以前`开发部署时的效率非常的低`
那这个问题docker又是如何解决的呢
我们来看一下
那既然我们刚才说了
每一个应用都有自己`所需要的依赖和函数库`
那为什么我们不`把这些依赖函数库一起打包`呢
`所以docker就干了这件事情`
你njs你需要什么依赖





我给你打包起来
形成一个整体
然后呢我还给你放到一个隔离的容器里去运行
每一个应用我都这么去做
你需要什么依赖啊
你这mysql需要什么
我都给你准备好
然后呢打成一个包
你将来要部署时
我连着包一起扔过去
你还考虑依赖的问题吗
不用考虑了吧
那有同学会说了
那你把他们扔到一台机器上
他们之间的依赖难道没有干扰吗
哎不会啊
因为我们的docker啊
会把这些打包好的程序
用一个隔离的容器去运行啊
会用到一种砂浆的技术
它们相互之间不可见
这个问题不就解决了吗
当然这只是解决了我们刚才讲的
混乱依赖的问题
对不对
那有了docker依赖
你不用去管了
应用程序随时都可以运行
但是仅限于同一个操作系统
同学们
因为你在打包这个应用时
你肯定会基于某种操作系统去打包吧
比如这个应用是鲁班图版本的
那么它的依赖和函数库
肯定也是欧bunt版本的吧
那你把这个打包好的程序扔到centos上
你觉得它可以运行吗
所以呢docker又怎么来解决这个问题呢
唉要想了解docker如何跨系统运行
我们得先知道操作系统的结构
这儿呢我们有版图为例
给大家讲一讲操作系统的结构啊
没你想的那么复杂
同学们别着急啊
其实所有的linux内核的操作系统
它都可以分成两层
一层呢是大家共享的内核
linux内核
不管是bo还是centos
fedora red hat
他们的内核都是linux
而区别是什么
上层的系统应用不同
鲁班图和centos它们的应用是不一样的
内核是相同的
但内核干什么事儿呢
内核负责与计算机硬件进行交互
比方说我去调用一下cpu啊
调用一下内存啊
读一下文件
happy一个进程之类的
这些都是内核要做的事情
而内核会把这些事情啊变成一个一个的指令
你调用这些指令就可以操作计算机硬件了
但可惜的是
这些个指令大多比较简陋
如果你要基于这些指令去开发应用
那可就太麻烦了
所以说呀我们就有了系统应用
系统应用
比如说wbt
他干了什么事
他会将内核的指令进行一个组装
再封装
形成函数区域多的函数形成了函数库
那么程序员可以基于这些函数库进行开发程序
调用我们的函数库
函数库
调用内核指令指令去调用我们的计算机硬件
从而实现我们这个应用的一个执行
这就是我们linux系统的一个结构
以及应用的执行原理了
那么问题来了
一个ubuntu系统上的应用
为什么不能在sl上运行呢
我们来看一下啊
比方说我现在有一个渗透系统
有一个无buntu系统
它俩的内核是完全一样的
那系统应用不同
也就是说函数库不同
可能五班图上有的函数库sentence上的不一定有
或者名字可能不一样
那这个时候我们把一个鲁班上的mysql应用给它
迁移到了cs上
尝试去执行
你会发现当他去调用一个函数库
是因为他代码写死的嘛
就调一个函数库
而发现这个函数库在center上根本不存在
那肯定会程序报错呀
这就是为什么我们的应用
不能跨系统运行的原因
那针对这样的一个问题
我们docker干了什么事呢
既然每个应用都依赖于系统函数库
我为什么不把它的系统函数库跟他一起打包呢
这样一来不就不愁找不到函数库了吗
所以docker的解决方案就是
将用户程序与系统调用的这个函数库一起打包
也就是说比如说我来打包一个这个mysql
那你mysql需要自己的一些依赖
那同时你还需要一些系统函数库
比如乌班图的函数库
那我就把乌班图的函数库
然后你自己的依赖等等全打包成一个整体
那么我们的这个mysql应用
node js应用
你随便放到任何的linux操作系统上
只要你内核是linux内核
我在执行的时候
我调用我打包好的这个函数库
而这个函数库直接调用操作系统的什么内核
而内核直接访问硬件
这个调用是不是就完成了
它还需要去管系统应用是什么吗
不需要
因为他自己就有好
那通过这种方式
`我们的docker是不是就解决了跨系统的问题了     `
`你可以认为docker打包好的程序包
可以运行在任何一个linux内核的操作系统上`
那我们来总结一下docker如何解决
我们之前所说的两个问题
第一不同组件依赖的兼容性问题
这个问题太好办了
因为docker可以把应用极其依赖函数库配置全打包
形成一个可移植的镜像
所以这个东西叫镜像啊
然后呢
你拿这玩意儿随便放到哪里去
它都是有自己的一套东西的
你还需要管依赖吗
不用了
并且为了防止不同应用依赖之间干扰
他还把它做了一个隔离
用沙箱机制
那大家互相看不到
那还有什么干扰呢

`那docker怎么解决开发测试
生产环境有差异的问题呢
我操作系统都不一样
你怎么办`
哎这个也很好办
`因为docker在打包的过程中
它是包含了完整运行环境的
不仅仅是应用和依赖
还包含了他所需要的系统函数库
甚至还有它的配置等等
因此呢它只需要依赖于系统的linux内核
而不是上层的这个呃不同的应用
那因此呢
它就可以在任意的linux操作系统上运行了`
好到这为止
我们就讲完了docker的工作原理了
总结一下道号是什么呀
docker就是一个用来快速交付应用
运行应用的一个技术
那它怎么实现快速的交付和运行呢
唉通过这么几点
第一打包
我们将程序及其依赖
运行环境配置等各种各样各样的需要的东西
全打包成一个镜像
而后我就可以任意迁移
任意的去做一个交付了
当然为了避免干扰
我们还利用沙箱机制形成隔离容器
这样呢用于应用之间的运行
互不干扰
各自是一个独立的整体
而且呀这种完整的程序包
它在运行时因为已经包含了自己所需要的一切
所以它启动的时候呢
只需要一个简单的命令就可以启动了
移除的时候也是如此
非常的方便和快捷
那因此呢我们再去做部署也好
运行也好
都非常快速
现在大家还没有体会
我们后面学习了docker的命令
你就会发现了好
那我们这节课就到这里了